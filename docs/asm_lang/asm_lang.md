# Шпаргалка по языку Ассемблер

## Структура команды

```armasm
метка
    команда операнд1, операнд2,... ; Комментарий
```

## Суффиксы

### Обновление флагов

| Суффикс | Описание |
|-|-|
| `S` | Обновить флаги `APSR` |

Пример:

```armasm
            ADD  R0, R1, R2     ; Сложение без обновления флагов APSR
            ADDS R0, R1         ; Сложение с обновлением флагов APSR
```

### Условное исполнение

| Суффикс | Описание | Флаги `APSR` |
|-|-|-|
| `EQ`| Равно (Equal) | `Z = 1` |
| `NE`| Не равно (Not Equal)| `Z = 0` |
| `CS`, `HS`| Перенос (Carry Set)/больше или равно для безнакового числа (Higher or Same) | `C = 1` |
| `CC`, `LO`| Нет переноса (Carry Clear)/меньше для безнакового числа (Lower) | `C = 0` |
| `MI`| Отрицательное число (Minus) | `N = 1` |
| `PL`| Положительное число (Plus) | `N = 0` |
| `VS`| Переполнение (Overflow Set) | `V = 1` |
| `VC`| Нет переполнения (Overflow Clear) | `V = 0` |
| `HI`| Больше для безнакового числа (Higher) | `C = 1 AND Z = 0` |
| `LS`| Меньше или равно для безнакового числа (Lower or Same) | `C = 0 OR Z = 1` |
| `GE`| Больше или равно для знакового числа (Greater or Equal) | `N = V` |
| `LT`| Меньше для знакового числа (Less Than) | `N != V` |
| `GT`| Больше для знакового числа (Greater Than) | `Z = 0 AND N = V` |
| `LE`| Меньше или равно для знакового числа (Less or Equal) | `Z = 1 OR N != V` |

> Суффиксы условного исполнения в процессоре Cortex-M0 работают только для команд перехода.

Пример:

- `BEQ` - переход если числа в результате предыдущих операций были равны (`Z = 1`)
- `BMI` - переход если в результате предущей операции получилось отрицательно число (`N = 1`)

## Команды

| Синтаксис (UAL)| Описание | Действие |
|-|-|-|
| `ADCS Rd, Rm` | Сложить регистры с переносом и обновить APSR | `Rd = Rd + Rm + C` |
| `ADDS Rd, Rn, Rm` | Сложить регистры и обновить APSR | `Rd = Rn + Rm` |
| `ADDS Rd, Rn, #imm3` | Сложить регистр с 3-х битовым числом и обновить APSR | `Rd = Rn + #imm3` |
| `ADDS Rd, #imm8` | Сложить регистр с 8-ми битовым числом и обновить APSR | `Rd = Rd + #imm8` |
| `ADD Rd, Rm` | Сложить регистры | `Rd = Rd + Rm` |
| `ADD Rd, SP, Rd` | Сложить указатель стека и регистр | `Rd = SP + Rd` |
| `ADD SP, Rm` | Сложить указатель стека и регистр | `SP = SP + Rm` |
| `ADD Rd, SP, #imm8` | Сложить указатель стека с 8-ми разрядном числом | `Rd = SP + ZeroExtend(#imm8 <<2)` |
| `ADD SP, SP, #imm7` | Сложить указатель стека с 7-ми разрядном числом | `SP = SP + ZeroExtend(#imm7 <<2)` |
| `ADR Rd, label` | Скопировать адрес в регистр. Синоним: `ADD <Rd>, PC, #imm8` | `Rd = Addr(label)` |
| `ANDS Rd, Rd, Rm` | Логическое побитовое И | `Rd = Rd AND Rm` |
| `ASRS Rd, Rd, Rm` | Арифметический сдвиг вправо | `Rd = Rd >> Rm` |
| `ASRS Rd, Rd, #imm5` | Арифметический сдвиг вправо | `Rd = Rd >> #imm5` |
| `BICS Rd, Rd, Rm` | Логический побитовый сброс | `Rd = Rd AND (NOT Rm)` |
| `B label` | Безусловный переход | `PC = Addr(label)` |
| `B <cond> label` | Условный переход | `PC = Addr(label)`  |
| `BL label` | Перейти и связать (адрес возврата сохраняется в LR) | `LR = PC + 2, PC = Addr(label)` | |
| `BX Rm` | Перейти по адресу в регистре с обменом  | `PC = Rm` |
| `BLX Rm` | Перейти на адрес в реестре и связать (адрес возврата хранится в LR) с обменом | `LR = PC + 2, PC = Rm` |
| `BKPT #imm8` | Программное прерывание | |
| `CMP Rn, Rm` | Сравнить два регистра и обновить APSR | `Rn - Rm` |
| `CMP Rn, #imm8` | Сравнить регистр с 8-ми битовым числом и обновить APSR | `Rn - #imm8` |
| `CMN Rn, Rm` | Сравнить с отрицательным числом | `Rn - ((NOT Rm) + 1)` |
| `CPSIE I` | Очистить  PRIMASK (разрешить прерывание) | |
| `CPSID I` | Установить PRIMASK (запретить прерывание) | |
| `DMB` | Барьер памяти данных, гарантирует, что все обращения к памяти будут завершены до того, как будет осуществлен новый доступ к памяти |
| `DSB` | Барьер синхронизации данных, гарантирует, что все обращения к памяти будут завершены до выполнения следующей инструкции |
| `EORS Rd, Rd, Rm` | Логическое исключающее ИЛИ между двумя регистрами | `Rd = Rd EOR Rm` |
| `ISB` | Барьер синхронизации инструкций; очищает конвейер и гарантирует, что все предыдущие инструкции завершены перед выполнением новых инструкций | |
| `LDM Rn, {Ra, Rb,..}` | Загрузить несколько регистров из памяти. Rn в списке регистров назначения и обновляется при загрузке | |
| `LDMIA Rn, {Ra, Rb,..}` | Загрузить несколько регистров из памяти. Rn не в списке регистров назначения и обновляется приращением адреса.  Альтернативный синтаксис: `LDMFD Rn, {Ra, Rb,..}` | |
| `LDR Rt, [Rn, Rm]` | Загрузить слово (4 байта) из памяти | `Rt = memory[Rn + Rm]` |
| `LDR Rt, [Rn, #imm5]` | Загрузить слово (4 байта) из памяти | `Rt = memory[Rn + #imm5<<2]` |
| `LDR Rt, [PC, #imm8]` | Загрузить слово (4 байта) из памяти | `Rt = memory[PC + #imm8<<2]` |
| `LDR Rt, [SP, #imm8]` | Загрузить слово (4 байта) из памяти | `Rt = memory[SP + #imm8<<2]` |
| `LDRH Rt, [Rn, Rm]` | Загрузить полуслово (2 байта) из памяти | `Rt = memory[Rn + Rm]` |
| `LDRH Rt, [Rn, #imm5]` | Загрузить полуслово (2 байта) из памяти | `Rt = memory[Rn + #imm5<<1]` |
| `LDRB Rt, [Rn, Rm]` | Загрузить байт из памяти | `Rt = memory[Rn + Rm]` |
| `LDRB Rt, [Rn, #imm5]` | Загрузить байт из памяти | `Rt = memory[Rn + #imm5]` |
| `LDRSH Rt, [Rn, Rm]` | Загрузить полуслово (2 байта) из памяти | `Rt = signed_extend(memory[Rn + Rm])` |
| `LDRSB Rt, [Rn, Rm]` | Загрузить байт со знаком из памяти | `Rt = signed_extend(memory[Rn + Rm])` |
| `LSLS Rd, Rd, Rm` | Логический сдвиг влево | `Rd = Rd << Rm` |
| `LSLS Rd, Rm, #imm5` | Логический сдвиг влево | `Rd = Rd << #imm5` |
| `LSRS Rd, Rd, Rm` | Логический сдвиг вправо | `Rd = Rd >> Rm` |
| `LSRS Rd, Rm, #imm5` | Логический сдвиг вправо | `Rd = Rd >> #imm5` |
| `MOV Rd, Rm` | Скопировать регистр | `Rd = Rm` |
| `MOVS Rd, Rm` | Скопировать регистр и обновить APSR | `Rd = Rm` |
| `MOVS Rd, #imm8` | Скопировать константу (sign extended) | `Rd = #imm8` |
| `MRS Rd, SpecialReg` | Скопировать специальный регистр в регистр | `Rd = SpecialReg` |
| `MSR SpecialReg, Rd` | Скопировать регистр в специальный регистр | `SpecialReg = Rd` |
| `MVNS Rd, Rm` | Логическое побитовое НЕ | `Rd = NOT(Rm)` |
| `MULS Rd, Rm, Rd` | Умножение | `Rd = Rm * Rd` |
| `NOP` | Нет операции | |
| `ORRS Rd, Rd, Rm` | Логическое ИЛИ | `Rd = Rd OR Rm` |
| `POP {Ra, Rb,..}, POP {Ra, Rb, .., PC}` | Прочитать один или несколько регистров из стека и обновить SP | |
| `PUSH {Ra, Rb,..} PUSH {Ra, Rb, .., LR}` | Сохранить один или несколько регистров в стеке и обновить SP | |
| `REV Rd, Rm` | Обратный порядок байт | `Rd = reversed(Rm)` |
| `REV16 Rd, Rm` | Обратный порядок байт в полуслове | |
| `REVSH Rd, Rm` | Обратный порядок байт в младшем полуслове и копирование бита знака на старшее полуслово | |
| `RORS Rd, Rd, Rm` | Циклический сдвиг вправо | |
| `RSBS Rd, Rn, #0` | Обратное вычитание | |
| `SBCS Rd, Rd, Rm` | Вычитание с переносом (заемом) | |
| `SEV` | Послать событие на все процессоры в многопроцессорной системе | |
| `STMIA Rn!, {Ra, Rb,....}` | Сохранить несколько регистров в памяти. Rn обновляется приращением адреса. | |
| `STR Rt, [Rn, Rm]` | Записать слово (4 байта) в память | `memory[Rn + Rm] = Rt` |
| `STR Rt, [Rn, #imm5]` | Записать слово (4 байта) в память | `memory[Rn + #imm5 << 2] = Rt` |
| `STR Rt, [SP, #imm8]` | Записать слово (4 байта) в память | `memory[SP + #imm8 << 2] = Rt` |
| `STRH Rt, [Rn, Rm]` | Записать полуслово (2 байта) в память | `memory[Rn + Rm] = Rt` |
| `STRH Rt, [Rn, #imm5]` | Записать полуслово (2 байта) в память | `memory[Rn + #imm5 << 1] = Rt` |
| `STRB Rt, [Rn, Rm` | Записать байт в память | `memory[Rn + Rm] = Rt` |
| `STRB Rt, [Rn, #imm5]` | Записать байт в память | `memory[Rn + #imm5] = Rt` |
| `SUBS Rd, Rn, Rm` | Вычесть два регистра | `Rd = Rn - Rm` |
| `SUBS Rd, Rn, #imm3` | Вычесть из регистра 3-х битовое числов | `Rd = Rn - #imm3` |
| `SUBS Rd, #imm8` | Вычесть из регистра 8-ми битовое число | `Rd = Rd - #imm8` |
| `SUB SP, SP, #imm7` | Вычесть из SP число | `SP = SP + ZeroExtend(#imm7 << 2)` |
| `SVC #imm8` | Программное прерывание (вызов супервизора) | |
| `SXTB Rd, Rm` | Знаковое расширение младшего байта до слова | |
| `SXTH Rd, Rm` | Знаковое расширение младшего полуслова до слова | |
| `TST Rn, Rm` | Тест (логическое побитовое И) | `Rn AND Rm` |
| `UXTB Rd, Rm` | Расширение младшего байта нулями до слова | |
| `UXTH Rd, Rm` | Расширение младшего полуслова нулями до слова | |
| `WFE` | Ожидание события, войти в режим сна | |
| `WFI` | Ожидание прерывания, войти в режим сна | |
| `YIELD` | Подсказка для переключения потоков и указания на то, что задача остановлена | |

## Псевдо команды

`LDR Rd, =imm32` - загрузить 32-х битное число в регистр. Псевдо команда преобразуется в команду `LDR Rd, [PC, #imm8]` для загрузки из пула литералов (части кода программы для констант).

Пример:

```armasm
            LDR R0, =0x12345678     ; Загрузить в R0 число `0x12345678`
            LDR R1, =42             ; Загрузить в R1 число 42
            LDR R2, ='A'            ; Загрузить в R2 код символа `A`
```

`LDR Rd, label` - загрузить данные по адресу. Адрес метки должен быть выравнен по слову (4 байта) и быть близко расположен к текущему PC.

Пример:

```armasm

            LDR R0, CONST_NUM       ; Загрузить в R0 данные по адресу CONST_NUM
            ...
            ALIGN 4

CONST_NUM   DCD 0x017
```

## Команды транслятора

| Синтаксис | Описание |
|-|-|
| `EQU` | Дать числу символическое макроопределение |
| `DCD` | Расположить данные в памяти (4 байта) |
| `DCW` | Расположить данные в памяти (2 байта) |
| `DCB` | Расположить данные в памяти (байт) |
| `ALIGN` | Выровнять текущую позицию (PC) по слову (4 байта) подставив код `0x00` для данных или команду `NOP` для программ |
| `ENTRY` | Указание на точку входа в программу |
| `END` | Указание на конец исходного файла |
| `EXPORT` | Указание на экспорт символа (символ становится глобальным) |
| `AREA`| Указание на новую секцию |

Пример:

```armasm
number      EQU     0x12        ; Макроопределение

            AREA    PROGRAM, CODE, READONLY ; Указание на расположение программы

            ALIGN               ; Выровнять по слову (4 байта)
const1      DCD  0x20000010     ; Вставить данные в код программы (слово)
const2      DCW  0x1234         ; Вставить данные в код программы (полуслово)
const3      DCB  1              ; Вставить данные в код программы (байт

            ALIGN               ; Выровнять по слову (4 байта)
            ENTRY               ; Указание на точку входа в программу

Reset_Handler

Stop        B    Stop

            ; Секция с таблицей векторов прерываний
            AREA    RESET, DATA, READONLY ; Указание на расположение векторов прерываний
            EXPORT  Vectors         ; Экспорт метки Vectors для компоновщика
Vectors
            DCD     0x20004000      ; Начало стека
            DCD     Reset_Handler   ; Вектор сброса

            END                     ; Команда транслятору об окончании текста программы
```
