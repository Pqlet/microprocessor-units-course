
| Синтаксис (UAL)| Описание | Выражение |
|-|-|-|
| `ADCS Rd, Rm` | Сложить регистры с переносом и обновить APSR | `Rd = Rd + Rm + C` |
| `ADDS Rd, Rn, Rm` | Сложить регистры и обновить APSR | `Rd = Rn + Rm` |
| `ADDS Rd, Rn, #imm3` | Сложить регистр с 3-х битовым числом и обновить APSR | `Rd = Rn + #imm3` |
| `ADDS Rd, #imm8` | Сложить регистр с 8-ми битовым числом и обновить APSR | `Rd = Rd + #imm8` |
| `ADD Rd, Rm` | Сложить регистры | `Rd = Rd + Rm` |
| `ADD Rd, SP, Rd` | Сложить указатель стека и регистр | `Rd = SP + Rd` |
| `ADD SP, Rm` | Сложить указатель стека и регистр | `SP = SP + Rm` |
| `ADD Rd, SP, #imm8` | Сложить указатель стека с 8-ми разрядном числом | `Rd = SP + ZeroExtend(#imm8 <<2)` |
| `ADD SP, SP, #imm7` | Сложить указатель стека с 7-ми разрядном числом | `SP = SP + ZeroExtend(#imm7 <<2)` |
| `ADR Rd, label` | Скопировать адрес в регистр. Синоним: `ADD <Rd>, PC, #imm8` | `Rd = Addr(label)` |
| `ANDS Rd, Rd, Rm` | Логическое побитовое И | `Rd = Rd AND Rm` |
| `ASRS Rd, Rd, Rm` | Арифметический сдвиг вправо | `Rd = Rd >> Rm` |
| `ASRS Rd, Rd, #imm5` | Арифметический сдвиг вправо | `Rd = Rd >> #imm5` |
| `BICS Rd, Rd, Rm` | Логический побитовый сброс | `Rd = Rd AND (NOT Rm)` |
| `B label` | Безусловный переход | `PC = Addr(label)` |
| `B <cond> label` | Условный переход | `PC = Addr(label)`  |
| `BL label` | Перейти и связать (адрес возврата сохраняется в LR) | `LR = PC + 2, PC = Addr(label)` | |
| `BX Rm` | Перейти по адресу в регистре с обменом  | `PC = Rm` |
| `BLX Rm` | Перейти на адрес в реестре и связать (адрес возврата хранится в LR) с обменом | `LR = PC + 2, PC = Rm` |
| `BKPT #imm8` | Программное прерывание | |
| `CMP Rn, Rm` | Сравнить два регистра и обновить APSR | `Rn - Rm` |
| `CMP Rn, #imm8` | Сравнить регистр с 8-ми битовым числом и обновить APSR | `Rn - #imm8` |
| `CMN Rn, Rm` | Сравнить с отрицательным числом | `Rn - ((NOT Rm) + 1)` |
| `CPSIE I` | Очистить  PRIMASK (разрешить прерывание) | |
| `CPSID I` | Установить PRIMASK (запретить прерывание) | |
| `DMB` | Барьер памяти данных, гарантирует, что все обращения к памяти будут завершены до того, как будет осуществлен новый доступ к памяти |
| `DSB` | Барьер синхронизации данных, гарантирует, что все обращения к памяти будут завершены до выполнения следующей инструкции |
| `EORS Rd, Rd, Rm` | Логическое исключающее ИЛИ между двумя регистрами | `Rd = Rd EOR Rm` |
| `ISB` | Барьер синхронизации инструкций; очищает конвейер и гарантирует, что все предыдущие инструкции завершены перед выполнением новых инструкций | |
| `LDM Rn, {Ra, Rb,..}` | Загрузить несколько регистров из памяти. Rn в списке регистров назначения и обновляется при загрузке | |
| `LDMIA Rn, {Ra, Rb,..}` | Загрузить несколько регистров из памяти. Rn не в списке регистров назначения и обновляется приращением адреса.  Альтернативный синтаксис: `LDMFD Rn, {Ra, Rb,..}` | |
| `LDR Rt, [Rn, Rm]` | Загрузить слово (4 байта) из памяти | `Rt = memory[Rn + Rm]` |
| `LDR Rt, [Rn, #imm5]` | Загрузить слово (4 байта) из памяти | `Rt = memory[Rn + #imm5<<2]` |
| `LDR Rt, [PC, #imm8]` | Загрузить слово (4 байта) из памяти | `Rt = memory[PC + #imm8<<2]` |
| `LDR Rt, [SP, #imm8]` | Загрузить слово (4 байта) из памяти | `Rt = memory[SP + #imm8<<2]` |
| `LDRH Rt, [Rn, Rm]` | Загрузить полуслово (2 байта) из памяти | `Rt = memory[Rn + Rm]` |
| `LDRH Rt, [Rn, #imm5]` | Загрузить полуслово (2 байта) из памяти | `Rt = memory[Rn + #imm5<<1]` |
| `LDRB Rt, [Rn, Rm]` | Загрузить байт из памяти | `Rt = memory[Rn + Rm]` |
| `LDRB Rt, [Rn, #imm5]` | Загрузить байт из памяти | `Rt = memory[Rn + #imm5]` |
| `LDRSH Rt, [Rn, Rm]` | Загрузить полуслово (2 байта) из памяти | `Rt = signed_extend(memory[Rn + Rm])` |
| `LDRSB Rt, [Rn, Rm]` | Загрузить байт со знаком из памяти | `Rt = signed_extend(memory[Rn + Rm])` |
| `LSLS Rd, Rd, Rm` | Логический сдвиг влево | `Rd = Rd << Rm` |
| `LSLS Rd, Rm, #imm5` | Логический сдвиг влево | `Rd = Rd << #imm5` |
| `LSRS Rd, Rd, Rm` | Логический сдвиг вправо | `Rd = Rd >> Rm` |
| `LSRS Rd, Rm, #imm5` | Логический сдвиг вправо | `Rd = Rd >> #imm5` |
| `MOV Rd, Rm` | Скопировать регистр | `Rd = Rm` |
| `MOVS Rd, Rm` | Скопировать регистр и обновить APSR | `Rd = Rm` |
| `MOVS Rd, #imm8` | Скопировать константу (sign extended) | `Rd = #imm8` |
| `MRS Rd, SpecialReg` | Скопировать специальный регистр в регистр | `Rd = SpecialReg` |
| `MSR SpecialReg, Rd` | Скопировать регистр в специальный регистр | `SpecialReg = Rd` |
| `MVNS Rd, Rm` | Логическое побитовое НЕ | `Rd = NOT(Rm)` |
| `MULS Rd, Rm, Rd` | Умножение | `Rd = Rm * Rd` |
| `NOP` | Нет операции | |
| `ORRS Rd, Rd, Rm` | Логическое ИЛИ | `Rd = Rd OR Rm` |
| `POP {Ra, Rb,..}, POP {Ra, Rb, .., PC}` | Прочитать один или несколько регистров из стека и обновить SP | |
| `PUSH {Ra, Rb,..} PUSH {Ra, Rb, .., LR}` | Сохранить один или несколько регистров в стеке и обновить SP | |
| `REV Rd, Rm` | Обратный порядок байт | `Rd = reversed(Rm)` |
| `REV16 Rd, Rm` | Обратный порядок байт в полуслове | |
| `REVSH Rd, Rm` | Обратный порядок байт в младшем полуслове и копирование бита знака на старшее полуслово | |
| `RORS Rd, Rd, Rm` | Циклический сдвиг вправо | |
| `RSBS Rd, Rn, #0` | Обратное вычитание | |
| `SBCS Rd, Rd, Rm` | Вычитание с переносом (заемом) | |
| `SEV` | Послать событие на все процессоры в многопроцессорной системе | |
| `STMIA Rn!, {Ra, Rb,....}` | Сохранить несколько регистров в памяти. Rn обновляется приращением адреса. | |
| `STR Rt, [Rn, Rm]` | Записать слово (4 байта) в память | `memory[Rn + Rm] = Rt` |
| `STR Rt, [Rn, #imm5]` | Записать слово (4 байта) в память | `memory[Rn + #imm5 << 2] = Rt` |
| `STR Rt, [SP, #imm8]` | Записать слово (4 байта) в память | `memory[SP + #imm8 << 2] = Rt` |
| `STRH Rt, [Rn, Rm]` | Записать полуслово (2 байта) в память | `memory[Rn + Rm] = Rt` |
| `STRH Rt, [Rn, #imm5]` | Записать полуслово (2 байта) в память | `memory[Rn + #imm5 << 1] = Rt` |
| `STRB Rt, [Rn, Rm` | Записать байт в память | `memory[Rn + Rm] = Rt` |
| `STRB Rt, [Rn, #imm5]` | Записать байт в память | `memory[Rn + #imm5] = Rt` |
| `SUBS Rd, Rn, Rm` | Вычесть два регистра | `Rd = Rn - Rm` |
| `SUBS Rd, Rn, #imm3` | Вычесть из регистра 3-х битовое числов | `Rd = Rn - #imm3` |
| `SUBS Rd, #imm8` | Вычесть из регистра 8-ми битовое число | `Rd = Rd - #imm8` |
| `SUB SP, SP, #imm7` | Вычесть из SP число | `SP = SP + ZeroExtend(#imm7 << 2)` |
| `SVC #imm8` | Программное прерывание (вызов супервизора) | |
| `SXTB Rd, Rm` | Знаковое расширение младшего байта до слова | |
| `SXTH Rd, Rm` | Знаковое расширение младшего полуслова до слова | |
| `TST Rn, Rm` | Тест (логическое побитовое И) | `Rn AND Rm` |
| `UXTB Rd, Rm` | Расширение младшего байта нулями до слова | |
| `UXTH Rd, Rm` | Расширение младшего полуслова нулями до слова | |
| `WFE` | Ожидание события, войти в режим сна | |
| `WFI` | Ожидание прерывания, войти в режим сна | |
| `YIELD` | Подсказка для переключения потоков и указания на то, что задача остановлена | |
