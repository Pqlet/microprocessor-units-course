; \file    main.s
; \author  Александр Смирнов
; \version 1.0.0
; \date    7.09.2022
; \brief   Программа на языке Ассемблер (ARM) для учебного стенда на базе
;          STM32F072RBT6 в среде разработки Keil uVision 5.
;          Примеры использования команд обработки данных.

            ; Секция с программой
            AREA    PROGRAM, CODE, READONLY
            ALIGN
            ENTRY

Reset_Handler


            ; Арифметические команды
            ADDS R0, R1, #1     ; Вычислить R1 + 1 и поместить результат в R0, R0 = R1 + 1
            ADDS R1, #10        ; Вычислить R1 + 10 и поместить результат в R1, R1 = R1 + 10
            ADDS R2, R0, R1     ; Вычислить R0 + R1 и поместить результат в R2, R2 = R0 + R1
            ADCS R3, R2         ; Вычислить R3 + R2 + С (бит переноса) и поместить результат в R3, R3 = R3 + R2 + С
            SUBS R4, R2, R1     ; Вычислить R2 - R1 и поместить результат в R4, R4 = R2 - R1
            SUBS R5, #2         ; Вычислить R5 - 2 и поместить результат в R5, R5 = R5 - 2
            RSBS R6, R5, #0     ; Вычислить 0 - R5 и поместить результат в R6, R6 = 0 - R5
            MULS R1, R6, R1     ; Вычислить R6 * R1 и поместить результат в R1, R1 = R6 * R1


            ; Команды сравнения (результат не сохраняется, только обновляется APSR)
            CMP  R0, R1         ; Сравнить R0 и R1, R0 - R1
            CMP  R1, #0x14      ; Сравнить R1 и  число 0x14, R1 - 0x14
            CMN  R0, R5         ; Сравнить R0 и отрицательное R5, R0 + NEG(R5)


            ; Логические команды
            ANDS R0, R0, R1     ; Вычислить побитовое логическое И, R0 = R0 AND R1
            ORRS R1, R1, R2     ; Вычислить побитовое логическое ИЛИ, R1 = R1 OR R2
            EORS R2, R2, R3     ; Вычислить побитовое логическое Исключающее ИЛИ, R2 = R2 EOR R3
            BICS R3, R3, R4     ; Вычислить побитовое логическое И с инверсным вторым операндом, R3 = R3 AND NOT R4
            MVNS R4, R5         ; Вычислить побитовое логическое НЕ, R4 = NOT R5
            TST  R5, R6         ; Вычислить побитовое логическое И без сохранения результата, R5 AND R6


            ; Команды сдвига
            ASRS R1, R1, R4     ; Арифметический сдвиг вправо, R1 = R1 >> R4
            ASRS R2, R1, #2     ; Арифметический сдвиг вправо, R2 = R1 >> 2
            LSLS R1, R1, R4     ; Логический сдвиг влево, R1 = R1 << R4
            LSLS R2, R1, #3     ; Логический сдвиг влево, R2 = R1 << 3
            LSRS R2, R2, R4     ; Логический сдвиг вправо, R2 = R2 >> R4
            LSRS R2, R2, #4     ; Логический сдвиг вправо, R2 = R2 >> 4
            RORS R2, R2, R3     ; Циклический сдвиг вправо, R2 = R2 >> R3


            ; Команды расширения и обратного порядка
            REV  R0, R1         ; Обратный порядок байт, R0 = {R1[7:0] , R1[15:8], R1[23:16], R1[31:24]}
            REV16 R3, R1        ; Обратный порядок полуслов, R3 = {R1[23:16], R1[31:24], R1[7:0] , R1[15:8]}
            REVSH R4, R1        ; Обратный порядок байт младшего полуслова с расширением знака, R4 = SignExtend({R1[7:0] , R1[15:8]})
            SXTB R3, R1         ; Дополнение знаком младшего байта до слова, R3 = SignExtend(R1[7:0])
            SXTH R4, R1         ; Дополнение знаком младшего полуслова до байта, R4 = SignExtend(R1[15:0])
            UXTB R5, R1         ; Дополнение нулями младшего байта до слова, R5 = ZeroExtend(R1[7:0])
            UXTH R6, R1         ; Дополнение нулями младшего полуслова до слова, R6 = ZeroExtend(R1[15:0])


Stop        B    Stop           ; Бесконечный цикл


            ALIGN

            ; Секция с таблицей векторов прерываний
            AREA    RESET, DATA, READONLY ; Указание на расположение векторов прерываний
            EXPORT  Vectors         ; Экспорт метки Vectors для компоновщика
Vectors
            DCD     0x20004000      ; Начало стека (последний адрес ОЗУ)
            DCD     Reset_Handler   ; Вектор сброса (начало программы)

            END                     ; Команда транслятору об окончании текста программы